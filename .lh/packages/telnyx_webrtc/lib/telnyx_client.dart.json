{
    "sourceFile": "packages/telnyx_webrtc/lib/telnyx_client.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1722335352272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1722337544124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,8 +204,11 @@\n   /// communication with the Telnyx backend\n   void _connectWithCallBack(\n       PushMetaData? pushMetaData, OnOpenCallback openCallback) {\n     _logger.i('connect() ${pushMetaData?.toJson()}');\n+    if (isConnected() && pushMetaData?.voice_sdk_id != null) {\n+      disconnect();\n+    }\n     try {\n       if (pushMetaData?.voice_sdk_id != null) {\n         txSocket.hostAddress =\n             \"$_storedHostAddress?voice_sdk_id=${pushMetaData?.voice_sdk_id}\";\n"
                },
                {
                    "date": 1722338344381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -205,43 +205,44 @@\n   void _connectWithCallBack(\n       PushMetaData? pushMetaData, OnOpenCallback openCallback) {\n     _logger.i('connect() ${pushMetaData?.toJson()}');\n     if (isConnected() && pushMetaData?.voice_sdk_id != null) {\n-      disconnect();\n-    }\n-    try {\n-      if (pushMetaData?.voice_sdk_id != null) {\n-        txSocket.hostAddress =\n-            \"$_storedHostAddress?voice_sdk_id=${pushMetaData?.voice_sdk_id}\";\n-        _logger.i(\n-            'Connecting to WebSocket with voice_sdk_id :: ${pushMetaData?.voice_sdk_id}');\n-      } else {\n-        txSocket.hostAddress = _storedHostAddress;\n-        _logger.i('connecting to WebSocket $_storedHostAddress');\n-      }\n-      txSocket.connect();\n+      disconnectWithCallBck((code, reason) {\n+        try {\n+          if (pushMetaData?.voice_sdk_id != null) {\n+            txSocket.hostAddress =\n+                \"$_storedHostAddress?voice_sdk_id=${pushMetaData?.voice_sdk_id}\";\n+            _logger.i(\n+                'Connecting to WebSocket with voice_sdk_id :: ${pushMetaData?.voice_sdk_id}');\n+          } else {\n+            txSocket.hostAddress = _storedHostAddress;\n+            _logger.i('connecting to WebSocket $_storedHostAddress');\n+          }\n+          txSocket.connect();\n \n-      txSocket.onOpen = () {\n-        _closed = false;\n-        _connected = true;\n-        _logger.i('Web Socket is now connected');\n-        _onOpen();\n-        openCallback.call();\n-      };\n+          txSocket.onOpen = () {\n+            _closed = false;\n+            _connected = true;\n+            _logger.i('Web Socket is now connected');\n+            _onOpen();\n+            openCallback.call();\n+          };\n \n-      txSocket.onMessage = (dynamic data) {\n-        _onMessage(data);\n-      };\n+          txSocket.onMessage = (dynamic data) {\n+            _onMessage(data);\n+          };\n \n-      txSocket.onClose = (int closeCode, String closeReason) {\n-        _logger.i('Closed [$closeCode, $closeReason]!');\n-        _connected = false;\n-        _onClose(true, closeCode, closeReason);\n-      };\n-    } catch (e, s) {\n-      _logger.e(e.toString(), null, s);\n-      _connected = false;\n-      _logger.e('WebSocket $_storedHostAddress error: $e');\n+          txSocket.onClose = (int closeCode, String closeReason) {\n+            _logger.i('Closed [$closeCode, $closeReason]!');\n+            _connected = false;\n+            _onClose(true, closeCode, closeReason);\n+          };\n+        } catch (e, s) {\n+          _logger.e(e.toString(), null, s);\n+          _connected = false;\n+          _logger.e('WebSocket $_storedHostAddress error: $e');\n+        }\n+      });\n     }\n   }\n \n   void connect() {\n@@ -476,8 +477,26 @@\n     }\n   }\n \n   /// Closes the socket connection, effectively logging the user out.\n+  void disconnectWithCallBck(OnCloseCallback? closeCallback) {\n+    _invalidateGatewayResponseTimer();\n+    _resetGatewayCounters();\n+    _logger.i('disconnect()');\n+    if (_closed) return;\n+    // Don't wait for the WebSocket 'close' event, do it now.\n+    _closed = true;\n+    _connected = false;\n+    _registered = false;\n+    try {\n+      txSocket.close();\n+      closeCallback?.call(0, 'Client send disconnect');\n+    } catch (error) {\n+      _logger.e('close() | error closing the WebSocket: $error');\n+    }\n+  }\n+\n+  /// Closes the socket connection, effectively logging the user out.\n   void disconnect() {\n     _invalidateGatewayResponseTimer();\n     _resetGatewayCounters();\n     _logger.i('disconnect()');\n"
                },
                {
                    "date": 1722339563242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -481,9 +481,12 @@\n   void disconnectWithCallBck(OnCloseCallback? closeCallback) {\n     _invalidateGatewayResponseTimer();\n     _resetGatewayCounters();\n     _logger.i('disconnect()');\n-    if (_closed) return;\n+    if (_closed) {\n+      closeCallback?.call(0, 'Client send disconnect');\n+    }\n+    ;\n     // Don't wait for the WebSocket 'close' event, do it now.\n     _closed = true;\n     _connected = false;\n     _registered = false;\n"
                },
                {
                    "date": 1722339569419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,9 +484,8 @@\n     _logger.i('disconnect()');\n     if (_closed) {\n       closeCallback?.call(0, 'Client send disconnect');\n     }\n-    ;\n     // Don't wait for the WebSocket 'close' event, do it now.\n     _closed = true;\n     _connected = false;\n     _registered = false;\n"
                },
                {
                    "date": 1722339885445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -483,8 +483,9 @@\n     _resetGatewayCounters();\n     _logger.i('disconnect()');\n     if (_closed) {\n       closeCallback?.call(0, 'Client send disconnect');\n+      return;\n     }\n     // Don't wait for the WebSocket 'close' event, do it now.\n     _closed = true;\n     _connected = false;\n"
                },
                {
                    "date": 1722339923256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,9 +204,9 @@\n   /// communication with the Telnyx backend\n   void _connectWithCallBack(\n       PushMetaData? pushMetaData, OnOpenCallback openCallback) {\n     _logger.i('connect() ${pushMetaData?.toJson()}');\n-    if (isConnected() && pushMetaData?.voice_sdk_id != null) {\n+    if (pushMetaData?.voice_sdk_id != null) {\n       disconnectWithCallBck((code, reason) {\n         try {\n           if (pushMetaData?.voice_sdk_id != null) {\n             txSocket.hostAddress =\n"
                },
                {
                    "date": 1722340872451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -855,6 +855,7 @@\n \n   void _resetGatewayCounters() {\n     _registrationRetryCounter = 0;\n     _connectRetryCounter = 0;\n+    _waitingForReg = true;\n   }\n }\n"
                },
                {
                    "date": 1722341109941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -856,6 +856,7 @@\n   void _resetGatewayCounters() {\n     _registrationRetryCounter = 0;\n     _connectRetryCounter = 0;\n     _waitingForReg = true;\n+    gatewayState = GatewayState.IDLE;\n   }\n }\n"
                },
                {
                    "date": 1722354799062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -632,12 +632,16 @@\n                         'GATEWAY UNREGISTERED :: ${stateMessage.toString()}');\n                     gatewayState = GatewayState.UNREGISTER;\n                     break;\n                   }\n+                case GatewayState.ATTACHED:\n+                  {\n+                    _logger.i(\n+                        'GATEWAY ATTACHED :: ${stateMessage.toString()}');\n+                    break;\n+                  }\n                 default:\n                   {\n-                    _invalidateGatewayResponseTimer();\n-                    _resetGatewayCounters();\n                     _logger.i(\n                         'GATEWAY REGISTRATION :: Unknown State ${stateMessage.toString()}');\n                   }\n               }\n"
                },
                {
                    "date": 1722361961505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -482,8 +482,9 @@\n     _invalidateGatewayResponseTimer();\n     _resetGatewayCounters();\n     _logger.i('disconnect()');\n     if (_closed) {\n+      _logger.i('WebSocket is already closed');\n       closeCallback?.call(0, 'Client send disconnect');\n       return;\n     }\n     // Don't wait for the WebSocket 'close' event, do it now.\n"
                },
                {
                    "date": 1722362066662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -492,9 +492,12 @@\n     _connected = false;\n     _registered = false;\n     try {\n       txSocket.close();\n+      Future.delayed(const Duration(milliseconds: 100), () { \n       closeCallback?.call(0, 'Client send disconnect');\n+\n+      })\n     } catch (error) {\n       _logger.e('close() | error closing the WebSocket: $error');\n     }\n   }\n"
                },
                {
                    "date": 1722362095652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -492,11 +492,11 @@\n     _connected = false;\n     _registered = false;\n     try {\n       txSocket.close();\n-      Future.delayed(const Duration(milliseconds: 100), () { \n+      Future.delayed(const Duration(milliseconds: 100), () {\n         closeCallback?.call(0, 'Client send disconnect');\n-      })\n+      });\n     } catch (error) {\n       _logger.e('close() | error closing the WebSocket: $error');\n     }\n   }\n"
                },
                {
                    "date": 1722362223118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -205,10 +205,9 @@\n   void _connectWithCallBack(\n       PushMetaData? pushMetaData, OnOpenCallback openCallback) {\n     _logger.i('connect() ${pushMetaData?.toJson()}');\n     if (pushMetaData?.voice_sdk_id != null) {\n-      disconnectWithCallBck((code, reason) {\n-        try {\n+       try {\n           if (pushMetaData?.voice_sdk_id != null) {\n             txSocket.hostAddress =\n                 \"$_storedHostAddress?voice_sdk_id=${pushMetaData?.voice_sdk_id}\";\n             _logger.i(\n@@ -240,9 +239,8 @@\n           _logger.e(e.toString(), null, s);\n           _connected = false;\n           _logger.e('WebSocket $_storedHostAddress error: $e');\n         }\n-      });\n     }\n   }\n \n   void connect() {\n"
                }
            ],
            "date": 1722335352272,
            "name": "Commit-0",
            "content": "// ignore_for_file: constant_identifier_names\n\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:ffi';\nimport 'package:logger/logger.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\nimport 'package:telnyx_webrtc/model/verto/send/attach_call_message.dart';\nimport 'package:telnyx_webrtc/peer/peer.dart';\nimport '/call.dart';\nimport '/config/telnyx_config.dart';\nimport '/model/gateway_state.dart';\nimport '/model/socket_method.dart';\nimport '/model/telnyx_socket_error.dart';\nimport '/model/verto/receive/received_message_body.dart';\nimport '/model/verto/send/gateway_request_message_body.dart';\nimport '/model/verto/send/login_message_body.dart';\nimport '/model/telnyx_message.dart';\nimport 'package:telnyx_webrtc/tx_socket.dart'\n    if (dart.library.js) 'package:telnyx_webrtc/tx_socket_web.dart';\nimport 'package:uuid/uuid.dart';\nimport 'package:flutter/foundation.dart';\n\nimport 'model/call_state.dart';\nimport 'model/jsonrpc.dart';\nimport 'model/push_notification.dart';\nimport 'model/verto/send/pong_message_body.dart';\n\ntypedef OnSocketMessageReceived = void Function(TelnyxMessage message);\ntypedef OnSocketErrorReceived = void Function(TelnyxSocketError message);\n\n/// The TelnyxClient class that can be used to control the SDK. Such as connect,\n/// disconnect, check gateway status or create instance of [Call]\n///\nclass _PreferencesStorage {\n  static const String _notification_key = 'com.telnyx.webrtc.notification';\n\n  static Future<Map<String, dynamic>?> getMetaData() async {\n    String metaData = await getString(_notification_key);\n    if (metaData.isEmpty) {\n      print(\"No Metadata found\");\n      return null;\n    }\n    saveMetadata(\"\");\n    return jsonDecode(metaData);\n  }\n\n  static void saveMetadata(String metaData) {\n    Logger().i(\"Save meta data $metaData\");\n    saveString(_notification_key, metaData);\n  }\n\n  static Future<void> saveString(String key, String data) async {\n    final SharedPreferences prefs = await SharedPreferences.getInstance();\n    await prefs.setString(key, data);\n  }\n\n  static Future<String> getString(String key) async {\n    final SharedPreferences prefs = await SharedPreferences.getInstance();\n    final String? preferences = prefs.getString(key);\n    if (preferences != null) {\n      return preferences;\n    } else {\n      return \"\";\n    }\n  }\n\n  static Future<void> saveBool(bool data, String key) async {\n    final SharedPreferences prefs = await SharedPreferences.getInstance();\n    await prefs.setBool(key, data);\n  }\n\n  static Future<bool> getBool(String key) async {\n    final SharedPreferences prefs = await SharedPreferences.getInstance();\n    final bool? value = prefs.getBool(key);\n    if (value != null) {\n      return value;\n    } else {\n      return false;\n    }\n  }\n}\n\nclass TelnyxClient {\n  late OnSocketMessageReceived onSocketMessageReceived;\n  late OnSocketErrorReceived onSocketErrorReceived;\n  String ringtonePath = \"\";\n  String ringBackpath = \"\";\n\n  TelnyxClient() {\n    // Default implementation of onSocketMessageReceived\n    onSocketMessageReceived = (TelnyxMessage message) {\n      switch (message.socketMethod) {\n        case SocketMethod.INVITE:\n          {\n            _logger.i(\n                'TelnyxClient :: onSocketMessageReceived  Override this on client side: $message');\n            break;\n          }\n        case SocketMethod.BYE:\n          {\n            _logger.i(\n                'TelnyxClient :: onSocketMessageReceived  Override this on client side: $message');\n            break;\n          }\n        default:\n          _logger.i(\n              'TelnyxClient :: onSocketMessageReceived  Override this on client side: $message');\n      }\n      _logger.i(\n          'TelnyxClient :: onSocketMessageReceived  Override this on client side: $message');\n    };\n  }\n\n  TxSocket txSocket = TxSocket(\"wss://rtc.telnyx.com:443\");\n  bool _closed = false;\n  bool _connected = false;\n  final _logger = Logger();\n\n  /// The current session ID related to this client\n  String sessid = const Uuid().v4();\n\n  // Gateway registration variables\n  static const int RETRY_REGISTER_TIME = 3;\n  static const int RETRY_CONNECT_TIME = 3;\n  static const int GATEWAY_RESPONSE_DELAY = 3000;\n\n  Timer? _gatewayResponseTimer;\n  bool _autoReconnectLogin = true;\n  bool _waitingForReg = true;\n  bool _pendingAnswerFromPush = false;\n  bool _pendingDeclineFromPush = false;\n  bool _isCallFromPush = false;\n  bool _registered = false;\n  int _registrationRetryCounter = 0;\n  int _connectRetryCounter = 0;\n  String gatewayState = GatewayState.IDLE;\n  Map<String, Call> calls = {};\n\n  Map<String, Call> activeCalls() {\n    return Map.fromEntries(calls.entries\n        .where((entry) => entry.value.callState == CallState.active));\n  }\n\n  // For instances where the SDP is not contained within ANSWER, but received early via a MEDIA message\n  bool earlySDP = false;\n\n  final String _storedHostAddress = \"wss://rtc.telnyx.com:443\";\n  CredentialConfig? storedCredentialConfig;\n  TokenConfig? storedTokenConfig;\n\n  /// Returns whether or not the client is connected to the socket connection\n  bool isConnected() {\n    return _connected;\n  }\n\n  /// Returns the current Gateway state for the socket connection\n  String getGatewayStatus() {\n    return gatewayState;\n  }\n\n  /// Handles the push notification received from the backend\n  /// and initiates the connection with the provided [pushMetaData]\n  /// and [credentialConfig] or [tokenConfig]\n  /// If the push notification is received while the client is not connected\n  void handlePushNotification(PushMetaData pushMetaData,\n      CredentialConfig? credentialConfig, TokenConfig? tokenConfig) {\n    print(jsonEncode(pushMetaData));\n    _isCallFromPush = true;\n\n    if (pushMetaData.isAnswer == true) {\n      print(\"_pendingAnswerFromPush true\");\n      _pendingAnswerFromPush = true;\n    } else {\n      print(\"_pendingAnswerFromPush false\");\n    }\n\n    if (pushMetaData.isDecline == true) {\n      _pendingDeclineFromPush = true;\n    }\n\n    _connectWithCallBack(pushMetaData, () {\n      if (credentialConfig != null) {\n        credentialLogin(credentialConfig);\n      } else if (tokenConfig != null) {\n        tokenLogin(tokenConfig);\n      }\n    });\n  }\n\n  static void setPushMetaData(Map<String, dynamic> pushMetaData,\n      {bool isAnswer = false, bool isDecline = false}) {\n    Map<String, dynamic> metaData = jsonDecode(pushMetaData[\"metadata\"]);\n    metaData[\"isAnswer\"] = isAnswer;\n    metaData[\"isDecline\"] = isDecline;\n    _PreferencesStorage.saveMetadata(jsonEncode(metaData));\n  }\n\n  static Future<Map<String, dynamic>?> getPushData() async {\n    return await _PreferencesStorage.getMetaData();\n  }\n\n  /// Create a socket connection for\n  /// communication with the Telnyx backend\n  void _connectWithCallBack(\n      PushMetaData? pushMetaData, OnOpenCallback openCallback) {\n    _logger.i('connect() ${pushMetaData?.toJson()}');\n    try {\n      if (pushMetaData?.voice_sdk_id != null) {\n        txSocket.hostAddress =\n            \"$_storedHostAddress?voice_sdk_id=${pushMetaData?.voice_sdk_id}\";\n        _logger.i(\n            'Connecting to WebSocket with voice_sdk_id :: ${pushMetaData?.voice_sdk_id}');\n      } else {\n        txSocket.hostAddress = _storedHostAddress;\n        _logger.i('connecting to WebSocket $_storedHostAddress');\n      }\n      txSocket.connect();\n\n      txSocket.onOpen = () {\n        _closed = false;\n        _connected = true;\n        _logger.i('Web Socket is now connected');\n        _onOpen();\n        openCallback.call();\n      };\n\n      txSocket.onMessage = (dynamic data) {\n        _onMessage(data);\n      };\n\n      txSocket.onClose = (int closeCode, String closeReason) {\n        _logger.i('Closed [$closeCode, $closeReason]!');\n        _connected = false;\n        _onClose(true, closeCode, closeReason);\n      };\n    } catch (e, s) {\n      _logger.e(e.toString(), null, s);\n      _connected = false;\n      _logger.e('WebSocket $_storedHostAddress error: $e');\n    }\n  }\n\n  void connect() {\n    _logger.i('connect()');\n    if (isConnected()) {\n      _logger.i('WebSocket $_storedHostAddress is already connected');\n      return;\n    }\n    _logger.i('connecting to WebSocket $_storedHostAddress');\n    try {\n      txSocket.onOpen = () {\n        _closed = false;\n        _connected = true;\n        _logger.i('Web Socket is now connected');\n        _onOpen();\n      };\n\n      txSocket.onMessage = (dynamic data) {\n        _onMessage(data);\n      };\n\n      txSocket.onClose = (int closeCode, String closeReason) {\n        _logger.i('Closed [$closeCode, $closeReason]!');\n        _connected = false;\n        _onClose(true, closeCode, closeReason);\n      };\n\n      txSocket.connect();\n    } catch (e, s) {\n      _logger.e(e.toString(), null, s);\n      _connected = false;\n      _logger.e('WebSocket $_storedHostAddress error: $e');\n    }\n  }\n\n  void _reconnectToSocket() {\n    txSocket.close();\n    txSocket.connect();\n    // Delay to allow connection\n    Timer(const Duration(seconds: 1), () {\n      if (storedCredentialConfig != null) {\n        credentialLogin(storedCredentialConfig!);\n      } else if (storedTokenConfig != null) {\n        tokenLogin(storedTokenConfig!);\n      }\n    });\n  }\n\n  /// The current instance of [Call] associated with this client. Can be used\n  /// to call call related functions such as hold/mute\n  Call? _call;\n\n  // Public getter to lazily initialize and return the value.\n  @Deprecated(\n      \"telnyxClient.call is deprecated, use telnyxClient.invite() or  telnyxClient.accept()\")\n  Call get call {\n    // If _call is null, initialize it with the default value.\n\n    _call ??= _createCall();\n    return _call!;\n  }\n\n  void _callEnded() {\n    _logger.i('Call Ended');\n    _call = null;\n  }\n\n  /// Creates an instance of [Call] that can be used to create invitations or\n  /// perform common call related functions such as ending the call or placing\n  /// yourself on hold/mute.\n  Call _createCall() {\n    // Set global call parameter\n    _call = Call(txSocket, this, sessid, ringtonePath, ringBackpath,\n        CallHandler((state) {\n      /*\n      * initialise this callback to handle call state changes on the client side\n      * */\n      _logger.i('Call state not overridden :Call State Changed to $state');\n    }), _callEnded);\n    return _call!;\n  }\n\n  /// Uses the provided [config] to send a credential login message to the Telnyx backend.\n  /// If successful, the gateway registration process will start.\n  ///\n  /// May return a [TelnyxSocketError] in the case of an authentication error\n  void credentialLogin(CredentialConfig config) {\n    storedCredentialConfig = config;\n    var uuid = const Uuid().v4();\n    var user = config.sipUser;\n    var password = config.sipPassword;\n    var fcmToken = config.notificationToken;\n    ringBackpath = config.ringbackPath ?? \"\";\n    ringtonePath = config.ringTonePath ?? \"\";\n    UserVariables? notificationParams;\n    _autoReconnectLogin = config.autoReconnect ?? true;\n\n    if (defaultTargetPlatform == TargetPlatform.android) {\n      notificationParams = UserVariables(\n          pushDeviceToken: fcmToken, pushNotificationProvider: \"android\");\n    } else if (defaultTargetPlatform == TargetPlatform.iOS) {\n      notificationParams = UserVariables(\n          pushDeviceToken: fcmToken, pushNotificationProvider: \"ios\");\n    }\n\n    var loginParams = LoginParams(\n      login: user,\n      passwd: password,\n      loginParams: [],\n      userVariables: notificationParams,\n      attachCall: \"true\",\n    );\n    var loginMessage = LoginMessage(\n        id: uuid,\n        method: SocketMethod.LOGIN,\n        params: loginParams,\n        jsonrpc: JsonRPCConstant.jsonrpc);\n\n    String jsonLoginMessage = jsonEncode(loginMessage);\n\n    txSocket.send(jsonLoginMessage);\n  }\n\n  /// Uses the provided [config] to send a token login message to the Telnyx backend.\n  /// If successful, the gateway registration process will start.\n  ///\n  /// May return a [TelnyxSocketError] in the case of an authentication error\n  void tokenLogin(TokenConfig config) {\n    storedTokenConfig = config;\n    var uuid = const Uuid().v4();\n    var token = config.sipToken;\n    var fcmToken = config.notificationToken;\n    ringBackpath = config.ringbackPath ?? \"\";\n    ringtonePath = config.ringTonePath ?? \"\";\n    UserVariables? notificationParams;\n    _autoReconnectLogin = config.autoReconnect ?? true;\n\n    if (defaultTargetPlatform == TargetPlatform.android) {\n      notificationParams = UserVariables(\n          pushDeviceToken: fcmToken, pushNotificationProvider: \"android\");\n    } else if (defaultTargetPlatform == TargetPlatform.iOS) {\n      notificationParams = UserVariables(\n          pushDeviceToken: fcmToken, pushNotificationProvider: \"ios\");\n    }\n\n    var loginParams = LoginParams(\n        loginToken: token,\n        loginParams: [],\n        userVariables: notificationParams,\n        sessionId: sessid,\n        attachCall: \"true\");\n    var loginMessage = LoginMessage(\n        id: uuid,\n        method: SocketMethod.LOGIN,\n        params: loginParams,\n        jsonrpc: JsonRPCConstant.jsonrpc);\n\n    String jsonLoginMessage = jsonEncode(loginMessage);\n    _logger.i('Token Login Message $jsonLoginMessage');\n    txSocket.send(jsonLoginMessage);\n  }\n\n  // Creates an invitation to send to a [destinationNumber] or SIP Destination\n  /// using the provided [callerName], [callerNumber] and a [clientState]\n  Call newInvite(String callerName, String callerNumber,\n      String destinationNumber, String clientState,\n      {Map<String, String> customHeaders = const {}}) {\n    Call inviteCall = _createCall();\n\n    inviteCall.sessionCallerName = callerName;\n    inviteCall.sessionCallerNumber = callerNumber;\n    inviteCall.sessionDestinationNumber = destinationNumber;\n    inviteCall.sessionClientState = clientState;\n    customHeaders = customHeaders;\n    inviteCall.callId = const Uuid().v4();\n    var base64State = base64.encode(utf8.encode(clientState));\n\n    inviteCall.peerConnection = Peer(txSocket);\n    inviteCall.peerConnection?.invite(\n        callerName,\n        callerNumber,\n        destinationNumber,\n        base64State,\n        inviteCall.callId!,\n        inviteCall.sessid,\n        customHeaders);\n    //play ringback tone\n    inviteCall.playAudio(ringBackpath);\n    inviteCall.callHandler.changeState(CallState.newCall, inviteCall);\n    return inviteCall;\n  }\n\n  /// Accepts the incoming call specified via the [invite] parameter, sending\n  /// your local specified [callerName], [callerNumber] and [clientState]\n  Call acceptCall(IncomingInviteParams invite, String callerName,\n      String callerNumber, String clientState,\n      {Map<String, String> customHeaders = const {}}) {\n    Call answerCall = getCallOrNull(invite.callID!) ?? _createCall();\n    answerCall.callId = invite.callID;\n\n    answerCall.sessionCallerName = callerName;\n    answerCall.sessionCallerNumber = callerNumber;\n    answerCall.sessionDestinationNumber =\n        invite.callerIdName ?? \"Unknown Caller\";\n    answerCall.sessionClientState = clientState;\n\n    var destinationNum = invite.callerIdNumber;\n\n    answerCall.peerConnection = Peer(txSocket);\n    answerCall.peerConnection?.accept(callerName, callerNumber, destinationNum!,\n        clientState, answerCall.callId!, invite, customHeaders);\n    answerCall.callHandler.changeState(CallState.active, answerCall);\n    answerCall.stopAudio();\n    if (answerCall.callId != null) {\n      updateCall(answerCall);\n    }\n    return answerCall;\n  }\n\n  Call? getCallOrNull(String callId) {\n    if (calls.containsKey(callId)) {\n      _logger.d(\"Invite Call found\");\n      return calls[callId];\n    }\n    _logger.d(\"Invite Call not found\");\n    return null;\n  }\n\n  void updateCall(Call call) {\n    if (calls.containsKey(call.callId)) {\n      calls[call.callId!] = call;\n    }\n  }\n\n  /// Closes the socket connection, effectively logging the user out.\n  void disconnect() {\n    _invalidateGatewayResponseTimer();\n    _resetGatewayCounters();\n    _logger.i('disconnect()');\n    if (_closed) return;\n    // Don't wait for the WebSocket 'close' event, do it now.\n    _closed = true;\n    _connected = false;\n    _registered = false;\n    _onClose(true, 0, 'Client send disconnect');\n    try {\n      txSocket.close();\n    } catch (error) {\n      _logger.e('close() | error closing the WebSocket: $error');\n    }\n  }\n\n  /// WebSocket Event Handlers\n  void _onOpen() {\n    _logger.i('WebSocket connected');\n  }\n\n  void _onClose(bool wasClean, int code, String reason) {\n    _logger.i('WebSocket closed');\n    if (wasClean == false) {\n      _logger.i('WebSocket abrupt disconnection');\n    }\n  }\n\n  void _onMessage(dynamic data) {\n    _logger.i('DEBUG MESSAGE: ${data.toString().trim()}');\n    if (data != null) {\n      if (data.toString().trim().isNotEmpty) {\n        _logger.i('Received WebSocket message :: ${data.toString().trim()}');\n\n        if (data.toString().trim().contains(\"error\")) {\n          var errorJson = jsonEncode(data.toString());\n          _logger\n              .i('Received WebSocket message - Contains Error :: $errorJson');\n          try {\n            ReceivedResult errorResult =\n                ReceivedResult.fromJson(jsonDecode(data.toString()));\n            onSocketErrorReceived.call(errorResult.error!);\n          } on Exception catch (e) {\n            _logger.e('Error parsing JSON: $e');\n          }\n        }\n\n        //Login success\n        if (data.toString().trim().contains(\"result\")) {\n          var paramJson = jsonEncode(data.toString());\n          _logger\n              .i('Received WebSocket message - Contains Result :: $paramJson');\n\n          try {\n            ReceivedResult stateMessage =\n                ReceivedResult.fromJson(jsonDecode(data.toString()));\n\n            var mainMessage = ReceivedMessage(\n                jsonrpc: stateMessage.jsonrpc,\n                method: SocketMethod.GATEWAY_STATE,\n                stateParams: stateMessage.resultParams?.stateParams);\n\n            if (stateMessage.resultParams != null) {\n              switch (stateMessage.resultParams?.stateParams?.state) {\n                case GatewayState.REGED:\n                  {\n                    if (!_registered) {\n                      _logger.i(\n                          'GATEWAY REGISTERED :: ${stateMessage.toString()}');\n                      _invalidateGatewayResponseTimer();\n                      _resetGatewayCounters();\n                      gatewayState = GatewayState.REGED;\n                      _waitingForReg = false;\n                      var message = TelnyxMessage(\n                          socketMethod: SocketMethod.CLIENT_READY,\n                          message: mainMessage);\n                      onSocketMessageReceived.call(message);\n                      if (_isCallFromPush) {\n                        //sending attach Call\n                        String platform =\n                            defaultTargetPlatform == TargetPlatform.android\n                                ? \"android\"\n                                : \"ios\";\n\n                        AttachCallMessage attachCallMessage = AttachCallMessage(\n                            method: SocketMethod.ATTACH_CALL,\n                            id: const Uuid().v4(),\n                            params: Params(\n                                pushNotificationProvider: platform,\n                                userVariables: <dynamic, dynamic>{\n                                  \"push_notification_environment\": \"debug\"\n                                },\n                                loginParams: <dynamic, dynamic>{}),\n                            jsonrpc: \"2.0\");\n                        txSocket.send(jsonEncode(attachCallMessage));\n                        _isCallFromPush = false;\n                      }\n                      _registered = true;\n                    }\n                    break;\n                  }\n                case GatewayState.FAILED:\n                  {\n                    _logger.i(\n                        'GATEWAY REGISTRATION FAILED :: ${stateMessage.toString()}');\n                    gatewayState = GatewayState.FAILED;\n                    _invalidateGatewayResponseTimer();\n                    var error = TelnyxSocketError(\n                        errorCode: TelnyxErrorConstants.gatewayFailedErrorCode,\n                        errorMessage: TelnyxErrorConstants.gatewayFailedError);\n                    onSocketErrorReceived(error);\n                    break;\n                  }\n                case GatewayState.UNREGED:\n                  {\n                    _logger.i('GATEWAY UNREGED :: ${stateMessage.toString()}');\n                    gatewayState = GatewayState.UNREGED;\n                    break;\n                  }\n                case GatewayState.REGISTER:\n                  {\n                    _logger\n                        .i('GATEWAY REGISTERING :: ${stateMessage.toString()}');\n                    gatewayState = GatewayState.REGISTER;\n                    break;\n                  }\n                case GatewayState.UNREGISTER:\n                  {\n                    _logger.i(\n                        'GATEWAY UNREGISTERED :: ${stateMessage.toString()}');\n                    gatewayState = GatewayState.UNREGISTER;\n                    break;\n                  }\n                default:\n                  {\n                    _invalidateGatewayResponseTimer();\n                    _resetGatewayCounters();\n                    _logger.i(\n                        'GATEWAY REGISTRATION :: Unknown State ${stateMessage.toString()}');\n                  }\n              }\n            }\n          } on Exception catch (e) {\n            _logger.e('Error parsing JSON: $e');\n          }\n        } else if (data.toString().trim().contains(\"method\")) {\n          //Received Telnyx Method Message\n          var messageJson = jsonDecode(data.toString());\n          _logger.i(\n              'Received WebSocket message - Contains Method :: $messageJson');\n          switch (messageJson['method']) {\n            case SocketMethod.PING:\n              {\n                var result = Result(message: \"PONG\", sessid: sessid);\n                var pongMessage = PongMessage(\n                    jsonrpc: JsonRPCConstant.jsonrpc,\n                    id: const Uuid().v4(),\n                    result: result);\n                String jsonPongMessage = jsonEncode(pongMessage);\n                txSocket.send(jsonPongMessage);\n                break;\n              }\n            case SocketMethod.CLIENT_READY:\n              {\n                if (gatewayState != GatewayState.REGED) {\n                  _logger.i('Retrieving Gateway state...');\n                  if (_waitingForReg) {\n                    _requestGatewayStatus();\n                    _gatewayResponseTimer = Timer(\n                        const Duration(milliseconds: GATEWAY_RESPONSE_DELAY),\n                        () {\n                      if (_registrationRetryCounter < RETRY_REGISTER_TIME) {\n                        if (_waitingForReg) {\n                          _onMessage(data);\n                        }\n                        _registrationRetryCounter++;\n                      } else {\n                        _logger.i('GATEWAY REGISTRATION TIMEOUT');\n                        var error = TelnyxSocketError(\n                            errorCode:\n                                TelnyxErrorConstants.gatewayTimeoutErrorCode,\n                            errorMessage:\n                                TelnyxErrorConstants.gatewayTimeoutError);\n                        onSocketErrorReceived(error);\n                      }\n                    });\n                  }\n                } else {\n                  ReceivedMessage clientReadyMessage =\n                      ReceivedMessage.fromJson(jsonDecode(data.toString()));\n                  var message = TelnyxMessage(\n                      socketMethod: SocketMethod.CLIENT_READY,\n                      message: clientReadyMessage);\n                  onSocketMessageReceived.call(message);\n                }\n                break;\n              }\n            case SocketMethod.INVITE:\n              {\n                _logger.i('INCOMING INVITATION :: $messageJson');\n                ReceivedMessage invite =\n                    ReceivedMessage.fromJson(jsonDecode(data.toString()));\n                var message = TelnyxMessage(\n                    socketMethod: SocketMethod.INVITE, message: invite);\n                //play ringtone for web\n                Call offerCall = _createCall();\n                offerCall.callId = invite.inviteParams?.callID;\n                calls[offerCall.callId!] = offerCall;\n                offerCall.callHandler\n                    .changeState(CallState.connecting, offerCall);\n                if (!_pendingAnswerFromPush) {\n                  offerCall.playRingtone(ringtonePath);\n                  offerCall.callHandler\n                      .changeState(CallState.ringing, offerCall);\n                } else {\n                  offerCall.acceptCall(\n                      invite.inviteParams!,\n                      invite.inviteParams!.calleeIdName ?? \"\",\n                      invite.inviteParams!.callerIdNumber ?? \"\",\n                      \"State\");\n                  _pendingAnswerFromPush = false;\n                  offerCall.callHandler\n                      .changeState(CallState.active, offerCall);\n                }\n                onSocketMessageReceived.call(message);\n                if (_pendingDeclineFromPush) {\n                  offerCall.endCall(invite.inviteParams?.callID);\n                  offerCall.callHandler.changeState(CallState.done, offerCall);\n                  _pendingDeclineFromPush = false;\n                }\n                break;\n              }\n            case SocketMethod.MEDIA:\n              {\n                _logger.i('MEDIA RECEIVED :: $messageJson');\n                ReceivedMessage mediaReceived =\n                    ReceivedMessage.fromJson(jsonDecode(data.toString()));\n                if (mediaReceived.inviteParams?.sdp != null) {\n                  Call? mediaCall = calls[mediaReceived.inviteParams?.callID];\n                  if (mediaCall == null) {\n                    _logger.d(\"Error : Call  is null from Media Message\");\n                    _sendNoCallError();\n                    return;\n                  }\n                  mediaCall?.onRemoteSessionReceived(\n                      mediaReceived.inviteParams?.sdp);\n                  earlySDP = true;\n                } else {\n                  _logger.d('No SDP contained within Media Message');\n                }\n                break;\n              }\n            case SocketMethod.ANSWER:\n              {\n                _logger.i('INVITATION ANSWERED :: $messageJson');\n                ReceivedMessage inviteAnswer =\n                    ReceivedMessage.fromJson(jsonDecode(data.toString()));\n                Call? answerCall = calls[inviteAnswer.inviteParams?.callID];\n                if (answerCall == null) {\n                  _logger.d(\"Error : Call  is null from Answer Message\");\n                  _sendNoCallError();\n                  return;\n                }\n                var message = TelnyxMessage(\n                    socketMethod: SocketMethod.ANSWER, message: inviteAnswer);\n                if (inviteAnswer.inviteParams?.sdp != null) {\n                  answerCall\n                      ?.onRemoteSessionReceived(inviteAnswer.inviteParams?.sdp);\n                  onSocketMessageReceived(message);\n                } else if (earlySDP) {\n                  onSocketMessageReceived(message);\n                } else {\n                  _logger.d(\n                      'No SDP provided for Answer or Media, cannot initialize call');\n                  answerCall.endCall(inviteAnswer.inviteParams?.callID);\n                }\n                earlySDP = false;\n                answerCall.stopAudio();\n                break;\n              }\n            case SocketMethod.BYE:\n              {\n                _logger.i('BYE RECEIVED :: $messageJson');\n                ReceivedMessage bye =\n                    ReceivedMessage.fromJson(jsonDecode(data.toString()));\n                Call? byeCall = calls[bye.inviteParams?.callID];\n                if (byeCall == null) {\n                  _logger.d(\"Error : Call  is null from Bye Message\");\n                  _sendNoCallError();\n                  return;\n                }\n                var message =\n                    TelnyxMessage(socketMethod: SocketMethod.BYE, message: bye);\n                onSocketMessageReceived(message);\n                byeCall.stopAudio();\n                calls.remove(byeCall.callId);\n                break;\n              }\n            case SocketMethod.RINGING:\n              {\n                _logger.i('RINGING RECEIVED :: $messageJson');\n                ReceivedMessage ringing =\n                    ReceivedMessage.fromJson(jsonDecode(data.toString()));\n                Call? ringingCall = calls[ringing.inviteParams?.callID];\n                if (ringingCall == null) {\n                  _logger.d(\"Error : Call  is null from Ringing Message\");\n                  _sendNoCallError();\n                  return;\n                }\n\n                _logger.i(\n                    'Telnyx Leg ID :: ${ringing.inviteParams?.telnyxLegId.toString()}');\n                var message = TelnyxMessage(\n                    socketMethod: SocketMethod.RINGING, message: ringing);\n                onSocketMessageReceived(message);\n                break;\n              }\n          }\n        } else {\n          _logger.i('Received and ignored empty packet');\n        }\n      } else {\n        _logger.i('Received and ignored empty packet');\n      }\n    }\n  }\n\n  void _sendNoCallError() {\n    var error = TelnyxSocketError(\n        errorCode: 404, errorMessage: TelnyxErrorConstants.callNotFound);\n    onSocketErrorReceived(error);\n  }\n\n  void _requestGatewayStatus() {\n    if (_waitingForReg) {\n      var uuid = const Uuid();\n      var gatewayRequestParams = GatewayRequestStateParams();\n      var gatewayRequestMessage = GatewayRequestMessage(\n          id: uuid.toString(),\n          method: SocketMethod.GATEWAY_STATE,\n          params: gatewayRequestParams,\n          jsonrpc: JsonRPCConstant.jsonrpc);\n\n      String jsonGatewayRequestMessage = jsonEncode(gatewayRequestMessage);\n\n      txSocket.send(jsonGatewayRequestMessage);\n    }\n  }\n\n  void _invalidateGatewayResponseTimer() {\n    _gatewayResponseTimer?.cancel();\n  }\n\n  void _resetGatewayCounters() {\n    _registrationRetryCounter = 0;\n    _connectRetryCounter = 0;\n  }\n}\n"
        }
    ]
}