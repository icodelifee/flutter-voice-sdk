{
    "sourceFile": "packages/telnyx_webrtc/lib/call.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1722353682409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1722353832867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,9 +115,10 @@\n \n     String jsonByeMessage = jsonEncode(byeMessage);\n \n     if (_txClient.gatewayState != GatewayState.REGED) {\n-      _logger.d(\"Session end gateway not registered\");\n+      _logger\n+          .d(\"Session end gateway not  registered ${_txClient.gatewayState}\");\n       return;\n     } else {\n       _logger.d(\"Session end peer connection null\");\n     }\n"
                },
                {
                    "date": 1722363799308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,12 +132,8 @@\n     stopAudio();\n     callHandler.changeState(CallState.done, this);\n     callEnded();\n     _txClient.calls.remove(callId);\n-    var message = TelnyxMessage(\n-        socketMethod: SocketMethod.BYE,\n-        message: ReceivedMessage(method: \"telnyx_rtc.bye\"));\n-    _txClient.onSocketMessageReceived.call(message);\n   }\n \n   /// Sends a DTMF message with the chosen [tone] to the call\n   /// specified via the [callID]\n"
                }
            ],
            "date": 1722353682409,
            "name": "Commit-0",
            "content": "import 'dart:convert';\n\nimport 'package:assets_audio_player/assets_audio_player.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:logger/logger.dart';\nimport 'package:telnyx_webrtc/model/jsonrpc.dart';\nimport 'package:telnyx_webrtc/telnyx_client.dart';\n\nimport '/model/socket_method.dart';\nimport '/model/verto/receive/received_message_body.dart';\nimport '/model/verto/send/send_bye_message_body.dart';\nimport '/model/verto/send/info_dtmf_message_body.dart';\nimport '/model/verto/send/invite_answer_message_body.dart';\nimport '/model/verto/send/modify_message_body.dart';\nimport '/peer/peer.dart' if (dart.library.html) '/web/peer.dart';\nimport 'package:telnyx_webrtc/tx_socket.dart'\n    if (dart.library.js) 'package:telnyx_webrtc/tx_socket_web.dart';\nimport 'package:uuid/uuid.dart';\nimport 'package:audioplayers/audioplayers.dart';\n\nimport 'model/call_state.dart';\nimport 'model/gateway_state.dart';\nimport 'model/telnyx_message.dart';\n\n\n\ntypedef CallStateCallback = void Function(CallState state);\n\nclass CallHandler {\n  late CallStateCallback onCallStateChanged;\n\n  CallHandler(this.onCallStateChanged);\n\n  void changeState(CallState state,Call call) {\n    // You can add any additional logic here before invoking the callback\n    call.callState = state;\n    onCallStateChanged(state);\n  }\n}\n/// The Call class which is used for call related methods such as hold/mute or\n/// creating invitations, declining calls, etc.\nclass Call {\n  Call(this._txSocket,this._txClient, this.sessid, this.ringToneFile, this.ringBackFile,this.callHandler,\n      this.callEnded);\n\n  late CallHandler callHandler;\n  late CallState callState;\n\n  final audioService = AudioService();\n  final mobileAudioPlayer =  AssetsAudioPlayer.newPlayer();\n  final Function callEnded;\n  final TxSocket _txSocket;\n  final TelnyxClient _txClient;\n  final String sessid;\n  final String ringBackFile;\n  final String ringToneFile;\n  String? callId;\n  Peer? peerConnection;\n\n  bool onHold = false;\n  String sessionCallerName = \"\";\n  String sessionCallerNumber = \"\";\n  String sessionDestinationNumber = \"\";\n  String sessionClientState = \"\";\n  Map<String, String> customHeaders = {};\n  final _logger = Logger();\n\n  /// Creates an invitation to send to a [destinationNumber] or SIP Destination\n  /// using the provided [callerName], [callerNumber] and a [clientState]\n  void newInvite(String callerName, String callerNumber,\n      String destinationNumber, String clientState,\n      {Map<String, String> customHeaders = const {}}) {\n     _txClient.newInvite(callerName, callerNumber, destinationNumber, clientState, customHeaders: customHeaders);\n\n  }\n\n  void onRemoteSessionReceived(String? sdp) {\n    if (sdp != null) {\n      peerConnection?.remoteSessionReceived(sdp);\n    } else {\n      ArgumentError(sdp);\n    }\n  }\n\n  /// Accepts the incoming call specified via the [invite] parameter, sending\n  /// your local specified [callerName], [callerNumber] and [clientState]\n  Call acceptCall(IncomingInviteParams invite, String callerName,\n      String callerNumber, String clientState,\n      {Map<String, String> customHeaders = const {}}) {\n      return _txClient.acceptCall(invite, callerName, callerNumber, clientState, customHeaders: customHeaders);\n  }\n\n  /// Attempts to end the call identified via the [callID]\n  void endCall(String? callID) {\n\n    if(callId == null){\n      _logger.d(\"Call ID is null\");\n      return;\n    }\n\n\n    var uuid = const Uuid().v4();\n    var byeDialogParams = ByeDialogParams(callId: callID ?? callId);\n\n    var byeParams = SendByeParams(\n        cause: CauseCode.USER_BUSY.name,\n        causeCode: CauseCode.USER_BUSY.index + 1,\n        dialogParams: byeDialogParams,\n        sessid: sessid);\n\n    var byeMessage = SendByeMessage(\n        id: uuid,\n        jsonrpc: JsonRPCConstant.jsonrpc,\n        method: SocketMethod.BYE,\n        params: byeParams);\n\n    String jsonByeMessage = jsonEncode(byeMessage);\n\n    if (_txClient.gatewayState != GatewayState.REGED){\n      _logger.d(\"Session end gateway not registered\");\n      return;\n    } else {\n      _logger.d(\"Session end peer connection null\");\n    }\n\n    _txSocket.send(jsonByeMessage);\n    if (peerConnection != null) {\n      peerConnection?.closeSession();\n    } else {\n      _logger.d(\"Session end peer connection null\");\n    }\n    stopAudio();\n    callHandler.changeState(CallState.done,this);\n    callEnded();\n    _txClient.calls.remove(callId);\n    var message =\n    TelnyxMessage(socketMethod: SocketMethod.BYE, message: ReceivedMessage(method: \"telnyx_rtc.bye\"));\n    _txClient.onSocketMessageReceived.call(message);\n  }\n\n  /// Sends a DTMF message with the chosen [tone] to the call\n  /// specified via the [callID]\n  void dtmf(String? callID, String tone) {\n    var uuid = const Uuid().v4();\n    var dialogParams = DialogParams(\n        attach: false,\n        audio: true,\n        callID: callId,\n        callerIdName: sessionCallerName,\n        callerIdNumber: sessionCallerNumber,\n        clientState: sessionClientState,\n        destinationNumber: sessionDestinationNumber,\n        remoteCallerIdName: \"\",\n        screenShare: false,\n        useStereo: false,\n        userVariables: [],\n        video: false);\n\n    var infoParams =\n        InfoParams(dialogParams: dialogParams, dtmf: tone, sessid: sessid);\n\n    var dtmfMessageBody = DtmfInfoMessage(\n        id: uuid,\n        jsonrpc: JsonRPCConstant.jsonrpc,\n        method: SocketMethod.INFO,\n        params: infoParams);\n\n    String jsonDtmfMessage = jsonEncode(dtmfMessageBody);\n    _txSocket.send(jsonDtmfMessage);\n  }\n\n  /// Either mutes or unmutes local audio based on the current mute state\n  void onMuteUnmutePressed() {\n    peerConnection?.muteUnmuteMic();\n  }\n\n  void enableSpeakerPhone(bool enable) {\n    peerConnection?.enableSpeakerPhone(enable);\n  }\n\n  /// Either places the call on hold, or unholds the call based on the current\n  /// hold state.\n  void onHoldUnholdPressed() {\n    if (onHold) {\n      _sendHoldModifier(\"unhold\");\n      onHold = false;\n      callHandler.changeState(CallState.active,this);\n    } else {\n      _sendHoldModifier(\"hold\");\n      onHold = true;\n      callHandler.changeState(CallState.held,this);\n    }\n  }\n\n  void _sendHoldModifier(String action) {\n    var uuid = const Uuid().v4();\n    var dialogParams = DialogParams(\n        attach: false,\n        audio: true,\n        callID: callId,\n        callerIdName: sessionCallerName,\n        callerIdNumber: sessionCallerNumber,\n        clientState: sessionClientState,\n        destinationNumber: sessionDestinationNumber,\n        remoteCallerIdName: \"\",\n        screenShare: false,\n        useStereo: false,\n        userVariables: [],\n        video: false);\n\n    var modifyParams = ModifyParams(\n        action: action, dialogParams: dialogParams, sessid: sessid);\n\n    var modifyMessage = ModifyMessage(\n        id: uuid.toString(),\n        method: SocketMethod.MODIFY,\n        params: modifyParams,\n        jsonrpc: JsonRPCConstant.jsonrpc);\n\n    String jsonModifyMessage = jsonEncode(modifyMessage);\n    _txSocket.send(jsonModifyMessage);\n  }\n\n  // Example file path for 'web/assets/audio/sound.wav'\n  void playAudio(String filePath) {\n    if (kIsWeb && filePath.isNotEmpty) {\n      audioService.playLocalFile(filePath);\n      return;\n    }\n    mobileAudioPlayer.open(\n      Audio(filePath),\n      autoStart: true,\n      showNotification: false,\n    );\n  }\n\n  // Play ringtone for only web, iOS and Android will use native audio player\n  void playRingtone(String filePath) {\n    if (kIsWeb && filePath.isNotEmpty) {\n      audioService.playLocalFile(filePath);\n      return;\n    }\n  }\n\n  void stopAudio() {\n    if (kIsWeb) {\n      audioService.stopAudio();\n      return;\n    }\n    mobileAudioPlayer.stop();\n  }\n}\n\nclass AudioService {\n  final AudioPlayer _audioPlayer = AudioPlayer();\n\n  Future<void> playLocalFile(String filePath) async {\n    // Ensure the file path is correct and accessible from the web directory\n    await _audioPlayer.play(DeviceFileSource(filePath));\n  }\n\n  Future<void> stopAudio() async {\n    // Ensure the file path is correct and accessible from the web directory\n    _audioPlayer.stop();\n    await _audioPlayer.release();\n  }\n}\n"
        }
    ]
}